/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author win11905
 */

#include <bits/stdc++.h>
#define all(x) (x).begin(), (x).end()
#define vi vector<int>
#define iii tuple<int, int, int>
#define long long long
#define pii pair<long, long>
#define x first
#define y second
using namespace std;
const long MOD = 1e9+7, LINF = 1e18 + 1e16;
const int INF = 1e9+1;
const double EPS = 1e-10;
const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

const int N = 1<<18;

int n, m;

#define var int p = 1, int l = 1, int r = n
#define mid (l + r >> 1)
#define lb p<<1, l, mid
#define rb p<<1|1, mid+1, r

class TaskB {
private:
    int in[N], out[N];
    long weight[N<<1];
    pii t[N<<1], lazy[N<<1];
    vector<int> g[N];
    void dfs(int u, int p) {
        static int idx = 0;
        in[u] = ++idx;
        for(int v : g[u]) if(v != p) dfs(v, u);
        out[u] = idx;
    }
    pii add(const pii &a, const pii &b) { return pii(a.x + b.x, a.y + b.y); }
    void addto(pii &a, const pii &b) { a = add(a, b); }
    void push(var) {
        if(lazy[p] == pii(0, 0)) return;
        addto(t[p], lazy[p]);
        if(l != r) {
            addto(lazy[p<<1], lazy[p]);
            addto(lazy[p<<1|1], lazy[p]);
        }
        lazy[p] = pii(0, 0);
    }
    template<typename T> void travel(int x, int y, const T &f, var) {
        push(p, l, r);
        if(x > r || l > y) return;
        if(x <= l && r <= y) return f(p, l, r);
        travel(x, y, f, lb), travel(x, y, f, rb);
        t[p] = pii(0, min(t[p<<1].y, t[p<<1|1].y));
    }
    int rpos[N<<1];
public:
    void solve(istream& cin, ostream& cout) {
        cin >> n >> m;
        for(int i = 1, u, v, w; i < n; ++i) {
            cin >> u >> v >> w;
            g[u].emplace_back(v), weight[i] = w;
            rpos[i] = v;
        }
        dfs(1, 0);
        for(int i = 1, u, v, w; i < n; ++i) {
            cin >> u >> v >> w;
            travel(in[rpos[i]], out[rpos[i]], [&](var) {
                lazy[p].x += weight[i], lazy[p].y += weight[i];
                push(p, l, r);
            });
            weight[i+n-1] = w, rpos[i+n-1] = u;
            travel(in[u], in[u], [&](var) {
                t[p].y += weight[i+n-1];
            });
        }
        for(int i = 0, a, b, c; i < m; ++i) {
            cin >> a >> b >> c;
            if(a == 1) {
                travel(in[rpos[b]], b < n ? out[rpos[b]] : in[rpos[b]], [&](var) {
                    if(b < n) lazy[p].x += c - weight[b];
                    lazy[p].y += c - weight[b];
                    push(p, l, r);
                });
                weight[b] = c;
            } else {
                long sum = 0, mn = 1e18;
                travel(in[c], in[c], [&](var) { sum += t[p].x; });
                travel(in[b], in[b], [&](var) { sum -= t[p].x; });
                if(in[b] > in[c] || out[c] > out[b])
                    travel(in[b], out[b], [&](var) { mn = min(mn, t[p].y); });
                else mn = 0;
                cout << sum + mn << endl;
            }
        }
    }
};

class Solver {
public:
    void solve(std::istream& in, std::ostream& out) {
        TaskB *obj = new TaskB();
        obj->solve(in, out);
    }
};

int32_t main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    Solver solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
