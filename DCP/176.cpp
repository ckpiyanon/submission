/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author win11905
 * - add query for each node
 * - solve find distance by centroid
 */

#include <bits/stdc++.h>
#define all(x) (x).begin(), (x).end()
#define long long long
#define pii pair<long, long>
#define x first
#define y second
using namespace std;
const long MOD = 1e9+7, LINF = 1e18 + 1e16;
const int INF = 1e9+1;
const double EPS = 1e-10;
const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

const int N = 3e5+5;

class dcp_176_re {
private:
    int n, m, step, A[N], d[N];
    bool check[N];
    pii mxp[N][2];
    int cstep[N];
    long answer[N];
    vector<int> g[N];
    vector<pii> que[N];
    int dfs_sz(int u, int p) {
        d[u] = 1;
        for(int v : g[u]) if(v != p and !check[v]) d[u] += dfs_sz(v, u);
        return d[u];
    }
    void find_centroid(int u, int p, int sz, int &ret) {
        bool st = true;
        for(int v : g[u]) if(v != p and !check[v]) {
            if(d[v] > sz/2) st = false;
            find_centroid(v, u, sz, ret);
        }
        if(sz - d[u] > sz/2) st = false;
        if(st) ret = u;
    }
    int get_centroid(int u) {
        int sz = dfs_sz(u, 0);
        int ans = -1;
        find_centroid(u, 0, sz, ans);
        return ans;
    }
    void dfs_fill(int u, int p, int start, int dis, long val, bool st) {
        if(cstep[dis] != step) mxp[dis][0] = mxp[dis][1] = pii(LINF, LINF), cstep[dis] = step;
        if(st) {
            if(mxp[dis][0].x == start) mxp[dis][0].y = min(mxp[dis][0].y, val);
            else if(mxp[dis][1].y > val) mxp[dis][1] = pii(start, val);
            if(mxp[dis][0].y > mxp[dis][1].y) swap(mxp[dis][0], mxp[dis][1]);
        } else {
            for(auto x : que[u]) {
                if(x.x - dis < 0) continue;
                if(cstep[x.x-dis] != step) mxp[x.x-dis][0] = mxp[x.x-dis][1] = pii(LINF, LINF), cstep[x.x-dis] = step;
                if(mxp[x.x-dis][0].x != start) answer[x.y] = min(answer[x.y], val + mxp[x.x-dis][0].y);
                else answer[x.y] = min(answer[x.y], val + mxp[x.x-dis][1].y);
            }
        }
        for(int v : g[u]) if(v != p and !check[v]) dfs_fill(v, u, start, dis+1, val + A[v], st);
    }
    void centroid_decom(int u) {
        check[u] = true;
        cstep[0] = ++step, mxp[0][0] = pii(0, A[u]);
        for(int v : g[u]) if(!check[v]) dfs_fill(v, u, v, 1, A[u] + A[v], true);
        for(int v : g[u]) if(!check[v]) dfs_fill(v, u, v, 1, A[v], false);
        for(auto x : que[u]) {
            if(cstep[x.x] != step) mxp[x.x][0] = mxp[x.x][1] = pii(LINF, LINF), cstep[x.x] = step;
            answer[x.y] = min(answer[x.y], mxp[x.x][0].y);
        }
        for(int v : g[u]) if(!check[v]) centroid_decom(get_centroid(v));
    }
public:
    void solve(istream& cin, ostream& cout) {
        cin >> n;
        for(int i = 1; i <= n; ++i) cin >> A[i];
        for(int i = 1, u, v; i < n; ++i) {
            cin >> u >> v;
            g[u].emplace_back(v), g[v].emplace_back(u);
        }
        cin >> m;
        for(int i = 0, u, w; i < m; ++i) {
            cin >> u >> w;
            que[u].emplace_back(w, i);
        }
        fill_n(answer, N, LINF);
        centroid_decom(get_centroid(1));
        for(int i = 0; i < m; ++i) cout << (answer[i] == LINF ? -1 : answer[i]) << endl;
    }
};

class Solver {
public:
    void solve(std::istream& in, std::ostream& out) {
        dcp_176_re *obj = new dcp_176_re();
        obj->solve(in, out);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    Solver solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}

