/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author win11905
 */

#include <bits/stdc++.h>
#define long long long
#define all(x) (x).begin(), (x).end()
#define mem(x) memset(x, 0, sizeof x)
#define pii pair<int, int>
#define x first
#define y second
using namespace std;
const long LINF = 1e18 + 1e16;
const int MOD = 1e9+7;
const double EPS = 1e-10;
const int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
const int N = 1e5+5;


class superxor {
private:
	using iii = tuple<int, int, int>;
	int n, m, k;
	bool check[N];
	vector<vector<pair<long, long> > > g;
	vector<tuple<long, long, long> > E;
	long d[N];
	void dfs(int u, int p) {
	    check[u] = true;
		for(auto v : g[u]) if(v.x != p) {
			if(check[v.x]) E.emplace_back(u, v.x, v.y);
			else d[v.x] = d[u] ^ v.y, dfs(v.x, u);
		}
	}
public:
	void solve(istream& cin, ostream& cout) {
		mem(check), mem(d);
		cin >> n >> m >> k;
		g.resize(n+1);
		for(int i = 0; i < m; ++i) {
		    long u, v, w; cin >> u >> v >> w;
			g[u].emplace_back(v, w);
			g[v].emplace_back(u, w);
		}
		dfs(1, 0);
		vector<long > mat, ret;
		for(auto x : E) mat.emplace_back(d[get<0>(x)] ^ d[get<1>(x)] ^ get<2>(x));
		for(int i = 62; ~i; --i) {
			long now = 0;
			for(auto &x : mat) if(x >> i & 1) now = x;
			if(!now) continue;
			ret.emplace_back(now);
			for(auto &x : mat) if(x >> i & 1) x ^= now;
		}
		for(int i = 0, u, v; i < k; ++i) {
			cin >> u >> v;
			long ans = d[u] ^ d[v];
			for(auto x : ret) if(ans < (ans ^ x)) ans ^= x;
			cout << ans << endl;
		}
	}
};

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	superxor solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
